/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (7.3.0).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package uasz.alumni.spi.api;

import uasz.alumni.spi.model.AdvancedSearchRequestDTO;
import uasz.alumni.spi.model.AdvancedSearchResultsDTO;
import uasz.alumni.spi.model.AlumniRequestDTO;
import uasz.alumni.spi.model.AlumniResponseDTO;
import uasz.alumni.spi.model.CodeValidationCheckDTO;
import uasz.alumni.spi.model.CodeValidationRequestDTO;
import uasz.alumni.spi.model.ConnexionRequestDTO;
import uasz.alumni.spi.model.ConnexionResponseDTO;
import uasz.alumni.spi.model.ErrorResponse;
import uasz.alumni.spi.model.EtudiantRequestDTO;
import uasz.alumni.spi.model.EtudiantResponseDTO;
import uasz.alumni.spi.model.IndexRequestDTO;
import uasz.alumni.spi.model.IndexResponseDTO;
import uasz.alumni.spi.model.IndexStatusResponseDTO;
import uasz.alumni.spi.model.RefreshTokenRequestDTO;
import uasz.alumni.spi.model.RoleRequestDTO;
import uasz.alumni.spi.model.RoleResponseDTO;
import uasz.alumni.spi.model.SearchResultsDTO;
import uasz.alumni.spi.model.SuggestionsResponseDTO;
import uasz.alumni.spi.model.TokenValidationResponse;
import uasz.alumni.spi.model.UtilisateurResponseDTO;
import io.swagger.v3.oas.annotations.ExternalDocumentation;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.HttpStatus;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.multipart.MultipartFile;

import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import jakarta.annotation.Generated;

@Generated(value = "org.openapitools.codegen.languages.SpringCodegen", date = "2025-11-29T08:40:07.510076584Z[Africa/Dakar]")
@Validated
@Tag(name = "Recherche Alumni", description = "Endpoints pour la recherche et l'indexation des profils alumni")
public interface ApiApi {

    /**
     * POST /api/v1/alumni/search/advanced : Recherche avancée avec tri et pagination
     * Recherche avancée d&#39;alumni avec support complet de pagination, tri multiple, et filtres complexes. Utilise un système de scoring pour pertinence. 
     *
     * @param advancedSearchRequestDTO  (required)
     * @return Résultats de recherche avancée récupérés avec succès (status code 200)
     *         or Requête de recherche invalide (status code 400)
     */
    @Operation(
        operationId = "advancedSearchAlumni",
        summary = "Recherche avancée avec tri et pagination",
        description = "Recherche avancée d'alumni avec support complet de pagination, tri multiple, et filtres complexes. Utilise un système de scoring pour pertinence. ",
        tags = { "Recherche Alumni" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Résultats de recherche avancée récupérés avec succès", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AdvancedSearchResultsDTO.class))
            }),
            @ApiResponse(responseCode = "400", description = "Requête de recherche invalide", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        },
        security = {
            @SecurityRequirement(name = "bearerAuth")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/alumni/search/advanced",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    @ResponseStatus(HttpStatus.OK)
    
    AdvancedSearchResultsDTO advancedSearchAlumni(
        @Parameter(name = "AdvancedSearchRequestDTO", description = "", required = true) @Valid @RequestBody AdvancedSearchRequestDTO advancedSearchRequestDTO
    );


    /**
     * POST /api/v1/auth/connexion : Connexion utilisateur
     * Authentifie un utilisateur (Admin, Étudiant ou Alumni) et retourne un token JWT. L&#39;utilisateur peut se connecter avec son email ou son username. 
     *
     * @param connexionRequestDTO  (required)
     * @return Connexion réussie (status code 200)
     *         or Identifiants invalides (status code 401)
     *         or Compte inactif ou supprimé (status code 403)
     */
    @Operation(
        operationId = "connexion",
        summary = "Connexion utilisateur",
        description = "Authentifie un utilisateur (Admin, Étudiant ou Alumni) et retourne un token JWT. L'utilisateur peut se connecter avec son email ou son username. ",
        tags = { "Authentification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Connexion réussie", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ConnexionResponseDTO.class))
            }),
            @ApiResponse(responseCode = "401", description = "Identifiants invalides", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "403", description = "Compte inactif ou supprimé", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/auth/connexion",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    @ResponseStatus(HttpStatus.OK)
    
    ConnexionResponseDTO connexion(
        @Parameter(name = "ConnexionRequestDTO", description = "", required = true) @Valid @RequestBody ConnexionRequestDTO connexionRequestDTO
    );


    /**
     * POST /api/v1/roles : Créer un nouveau rôle
     * Crée un nouveau rôle dans le système avec les données fournies
     *
     * @param roleRequestDTO  (required)
     * @return Rôle créé avec succès (status code 201)
     *         or Données de requête invalides (status code 400)
     *         or Un rôle avec le même nom existe déjà (status code 409)
     */
    @Operation(
        operationId = "createRole",
        summary = "Créer un nouveau rôle",
        description = "Crée un nouveau rôle dans le système avec les données fournies",
        tags = { "Rôle" },
        responses = {
            @ApiResponse(responseCode = "201", description = "Rôle créé avec succès", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = RoleResponseDTO.class))
            }),
            @ApiResponse(responseCode = "400", description = "Données de requête invalides"),
            @ApiResponse(responseCode = "409", description = "Un rôle avec le même nom existe déjà")
        },
        security = {
            @SecurityRequirement(name = "bearerAuth")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/roles",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    @ResponseStatus(HttpStatus.CREATED)
    
    RoleResponseDTO createRole(
        @Parameter(name = "RoleRequestDTO", description = "", required = true) @Valid @RequestBody RoleRequestDTO roleRequestDTO
    );


    /**
     * POST /api/v1/auth/deconnexion : Déconnexion utilisateur
     * Déconnecte l&#39;utilisateur et invalide le token JWT ainsi que le refresh token associé. Cette opération permet d&#39;assurer qu&#39;aucun token actif ne reste valide après déconnexion. 
     *
     * @return Déconnexion réussie (status code 204)
     *         or Non authentifié (status code 401)
     */
    @Operation(
        operationId = "deconnexion",
        summary = "Déconnexion utilisateur",
        description = "Déconnecte l'utilisateur et invalide le token JWT ainsi que le refresh token associé. Cette opération permet d'assurer qu'aucun token actif ne reste valide après déconnexion. ",
        tags = { "Authentification" },
        responses = {
            @ApiResponse(responseCode = "204", description = "Déconnexion réussie"),
            @ApiResponse(responseCode = "401", description = "Non authentifié", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        },
        security = {
            @SecurityRequirement(name = "bearerAuth")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/auth/deconnexion",
        produces = { "application/json" }
    )
    @ResponseStatus(HttpStatus.NO_CONTENT)
    
    void deconnexion(
        
    );


    /**
     * POST /api/v1/validation/envoyer
     *
     * @param codeValidationRequestDTO  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "envoyerCode",
        tags = { "code-validation-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = String.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/validation/envoyer",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    @ResponseStatus(HttpStatus.OK)
    
    String envoyerCode(
        @Parameter(name = "CodeValidationRequestDTO", description = "", required = true) @Valid @RequestBody CodeValidationRequestDTO codeValidationRequestDTO
    );


    /**
     * GET /api/v1/utilisateurs : Récupère tous les utilisateurs
     * Retourne la liste complète de tous les utilisateurs de la plateforme
     *
     * @return Liste des utilisateurs récupérée avec succès (status code 200)
     */
    @Operation(
        operationId = "getAll",
        summary = "Récupère tous les utilisateurs",
        description = "Retourne la liste complète de tous les utilisateurs de la plateforme",
        tags = { "Utilisateurs" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Liste des utilisateurs récupérée avec succès", content = {
                @Content(mediaType = "application/json", array = @ArraySchema(schema = @Schema(implementation = UtilisateurResponseDTO.class)))
            })
        },
        security = {
            @SecurityRequirement(name = "bearerAuth")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/utilisateurs",
        produces = { "application/json" }
    )
    @ResponseStatus(HttpStatus.OK)
    
    List<UtilisateurResponseDTO> getAll(
        
    );


    /**
     * GET /api/v1/roles : Récupérer tous les rôles
     * Retourne la liste de tous les rôles disponibles dans le système
     *
     * @return Liste des rôles récupérée avec succès (status code 200)
     *         or Erreur interne du serveur (status code 500)
     */
    @Operation(
        operationId = "getAllRoles",
        summary = "Récupérer tous les rôles",
        description = "Retourne la liste de tous les rôles disponibles dans le système",
        tags = { "Rôle" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Liste des rôles récupérée avec succès", content = {
                @Content(mediaType = "application/json", array = @ArraySchema(schema = @Schema(implementation = RoleResponseDTO.class)))
            }),
            @ApiResponse(responseCode = "500", description = "Erreur interne du serveur")
        },
        security = {
            @SecurityRequirement(name = "bearerAuth")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/roles",
        produces = { "application/json" }
    )
    @ResponseStatus(HttpStatus.OK)
    
    List<RoleResponseDTO> getAllRoles(
        
    );


    /**
     * GET /api/v1/alumni/index/status : Vérifier l&#39;état de l&#39;index
     * Récupère les informations sur l&#39;état actuel de l&#39;index de recherche des alumni. Inclut les statistiques et l&#39;état de santé de l&#39;index. 
     *
     * @return État de l&#39;index récupéré avec succès (status code 200)
     *         or Index non disponible (status code 503)
     */
    @Operation(
        operationId = "getIndexStatus",
        summary = "Vérifier l'état de l'index",
        description = "Récupère les informations sur l'état actuel de l'index de recherche des alumni. Inclut les statistiques et l'état de santé de l'index. ",
        tags = { "Recherche Alumni" },
        responses = {
            @ApiResponse(responseCode = "200", description = "État de l'index récupéré avec succès", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = IndexStatusResponseDTO.class))
            }),
            @ApiResponse(responseCode = "503", description = "Index non disponible", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        },
        security = {
            @SecurityRequirement(name = "bearerAuth")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/alumni/index/status",
        produces = { "application/json" }
    )
    @ResponseStatus(HttpStatus.OK)
    
    IndexStatusResponseDTO getIndexStatus(
        
    );


    /**
     * GET /api/v1/roles/{id} : Récupérer un rôle par son ID
     * Retourne les détails d&#39;un rôle spécifique en fonction de son identifiant
     *
     * @param id ID du rôle à récupérer (required)
     * @return Rôle trouvé et retourné avec succès (status code 200)
     *         or ID invalide (status code 400)
     *         or Rôle non trouvé (status code 404)
     */
    @Operation(
        operationId = "getRoleById",
        summary = "Récupérer un rôle par son ID",
        description = "Retourne les détails d'un rôle spécifique en fonction de son identifiant",
        tags = { "Rôle" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Rôle trouvé et retourné avec succès", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = RoleResponseDTO.class))
            }),
            @ApiResponse(responseCode = "400", description = "ID invalide"),
            @ApiResponse(responseCode = "404", description = "Rôle non trouvé")
        },
        security = {
            @SecurityRequirement(name = "bearerAuth")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/roles/{id}",
        produces = { "application/json" }
    )
    @ResponseStatus(HttpStatus.OK)
    
    RoleResponseDTO getRoleById(
        @Parameter(name = "id", description = "ID du rôle à récupérer", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id
    );


    /**
     * GET /api/v1/alumni/search/suggestions : Suggestions automatiques lors de la saisie
     * Fournit des suggestions d&#39;autocomplétion en temps réel pendant que l&#39;utilisateur tape. Optimisé pour une réponse rapide (&lt; 100ms). Retourne les 10 suggestions les plus pertinentes. 
     *
     * @param query Texte saisi par l&#39;utilisateur (minimum 2 caractères) (required)
     * @param field Champ sur lequel effectuer la suggestion (optional, default to nom)
     * @return Suggestions récupérées avec succès (status code 200)
     *         or Paramètres de requête invalides (status code 400)
     */
    @Operation(
        operationId = "getSuggestions",
        summary = "Suggestions automatiques lors de la saisie",
        description = "Fournit des suggestions d'autocomplétion en temps réel pendant que l'utilisateur tape. Optimisé pour une réponse rapide (< 100ms). Retourne les 10 suggestions les plus pertinentes. ",
        tags = { "Recherche Alumni" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Suggestions récupérées avec succès", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = SuggestionsResponseDTO.class))
            }),
            @ApiResponse(responseCode = "400", description = "Paramètres de requête invalides", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        },
        security = {
            @SecurityRequirement(name = "bearerAuth")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/alumni/search/suggestions",
        produces = { "application/json" }
    )
    @ResponseStatus(HttpStatus.OK)
    
    SuggestionsResponseDTO getSuggestions(
        @NotNull @Size(min = 2) @Parameter(name = "query", description = "Texte saisi par l'utilisateur (minimum 2 caractères)", required = true, in = ParameterIn.QUERY) @Valid @RequestParam(value = "query", required = true) String query,
        @Parameter(name = "field", description = "Champ sur lequel effectuer la suggestion", in = ParameterIn.QUERY) @Valid @RequestParam(value = "field", required = false, defaultValue = "nom") String field
    );


    /**
     * GET /api/v1/utilisateurs/actifs : Récupère les utilisateurs actifs
     * Retourne la liste des utilisateurs non supprimés (actifs) de la plateforme
     *
     * @return Liste des utilisateurs actifs récupérée avec succès (status code 200)
     */
    @Operation(
        operationId = "getUtilisateursActifs",
        summary = "Récupère les utilisateurs actifs",
        description = "Retourne la liste des utilisateurs non supprimés (actifs) de la plateforme",
        tags = { "Utilisateurs" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Liste des utilisateurs actifs récupérée avec succès", content = {
                @Content(mediaType = "application/json", array = @ArraySchema(schema = @Schema(implementation = UtilisateurResponseDTO.class)))
            })
        },
        security = {
            @SecurityRequirement(name = "bearerAuth")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/utilisateurs/actifs",
        produces = { "application/json" }
    )
    @ResponseStatus(HttpStatus.OK)
    
    List<UtilisateurResponseDTO> getUtilisateursActifs(
        
    );


    /**
     * POST /api/v1/alumni/index : Créer ou mettre à jour l&#39;index des profils d&#39;alumni
     * Crée ou met à jour l&#39;index de recherche des alumni. Cette opération peut prendre plusieurs minutes selon le nombre de profils. Opération réservée aux administrateurs. 
     *
     * @param indexRequestDTO  (optional)
     * @return Indexation lancée avec succès (opération asynchrone) (status code 202)
     *         or Accès refusé - Réservé aux administrateurs (status code 403)
     *         or Une indexation est déjà en cours (status code 409)
     */
    @Operation(
        operationId = "indexAlumni",
        summary = "Créer ou mettre à jour l'index des profils d'alumni",
        description = "Crée ou met à jour l'index de recherche des alumni. Cette opération peut prendre plusieurs minutes selon le nombre de profils. Opération réservée aux administrateurs. ",
        tags = { "Recherche Alumni" },
        responses = {
            @ApiResponse(responseCode = "202", description = "Indexation lancée avec succès (opération asynchrone)", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = IndexResponseDTO.class))
            }),
            @ApiResponse(responseCode = "403", description = "Accès refusé - Réservé aux administrateurs"),
            @ApiResponse(responseCode = "409", description = "Une indexation est déjà en cours", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        },
        security = {
            @SecurityRequirement(name = "bearerAuth")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/alumni/index",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    @ResponseStatus(HttpStatus.ACCEPTED)
    
    IndexResponseDTO indexAlumni(
        @Parameter(name = "IndexRequestDTO", description = "") @Valid @RequestBody(required = false) IndexRequestDTO indexRequestDTO
    );


    /**
     * POST /api/v1/auth/inscription-alumni : Inscrire un nouvel alumni
     * Crée un nouveau compte alumni.
     *
     * @param alumniRequestDTO  (required)
     * @return Alumni inscrit avec succès (status code 201)
     */
    @Operation(
        operationId = "inscrireAlumni",
        summary = "Inscrire un nouvel alumni",
        description = "Crée un nouveau compte alumni.",
        tags = { "Inscription Alumni" },
        responses = {
            @ApiResponse(responseCode = "201", description = "Alumni inscrit avec succès", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = AlumniResponseDTO.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/auth/inscription-alumni",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    @ResponseStatus(HttpStatus.CREATED)
    
    AlumniResponseDTO inscrireAlumni(
        @Parameter(name = "AlumniRequestDTO", description = "", required = true) @Valid @RequestBody AlumniRequestDTO alumniRequestDTO
    );


    /**
     * POST /api/v1/auth/inscription-etudiant : Inscrire un nouvel étudiant
     * Crée un nouveau compte étudiant.
     *
     * @param etudiantRequestDTO  (required)
     * @return Étudiant inscrit avec succès (status code 201)
     */
    @Operation(
        operationId = "inscrireEtudiant",
        summary = "Inscrire un nouvel étudiant",
        description = "Crée un nouveau compte étudiant.",
        tags = { "Inscription Étudiant" },
        responses = {
            @ApiResponse(responseCode = "201", description = "Étudiant inscrit avec succès", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = EtudiantResponseDTO.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/auth/inscription-etudiant",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    @ResponseStatus(HttpStatus.CREATED)
    
    EtudiantResponseDTO inscrireEtudiant(
        @Parameter(name = "EtudiantRequestDTO", description = "", required = true) @Valid @RequestBody EtudiantRequestDTO etudiantRequestDTO
    );


    /**
     * POST /api/v1/auth/refresh-token : Rafraîchir le token JWT
     * Permet de renouveler un token JWT expiré en utilisant le refresh token. Cette opération implémente la rotation des tokens : un nouveau refresh token est émis et l&#39;ancien est automatiquement invalidé pour renforcer la sécurité. 
     *
     * @param refreshTokenRequestDTO  (required)
     * @return Token rafraîchi avec succès (status code 200)
     *         or Refresh token invalide ou expiré (status code 401)
     */
    @Operation(
        operationId = "refreshToken",
        summary = "Rafraîchir le token JWT",
        description = "Permet de renouveler un token JWT expiré en utilisant le refresh token. Cette opération implémente la rotation des tokens : un nouveau refresh token est émis et l'ancien est automatiquement invalidé pour renforcer la sécurité. ",
        tags = { "Authentification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Token rafraîchi avec succès", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ConnexionResponseDTO.class))
            }),
            @ApiResponse(responseCode = "401", description = "Refresh token invalide ou expiré", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/auth/refresh-token",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    @ResponseStatus(HttpStatus.OK)
    
    ConnexionResponseDTO refreshToken(
        @Parameter(name = "RefreshTokenRequestDTO", description = "", required = true) @Valid @RequestBody RefreshTokenRequestDTO refreshTokenRequestDTO
    );


    /**
     * GET /api/v1/alumni/search : Recherche simple avec filtres
     * Recherche simple d&#39;alumni avec possibilité d&#39;appliquer des filtres basiques. Utilise la recherche full-text pour trouver des correspondances dans tous les champs. 
     *
     * @param q Terme de recherche général (optional)
     * @param filiere Filtrer par filière (optional)
     * @param niveau Filtrer par niveau d&#39;études (optional)
     * @param entreprise Filtrer par entreprise actuelle (optional)
     * @param ville Filtrer par ville (optional)
     * @return Résultats de recherche récupérés avec succès (status code 200)
     *         or Paramètres de recherche invalides (status code 400)
     */
    @Operation(
        operationId = "searchAlumni",
        summary = "Recherche simple avec filtres",
        description = "Recherche simple d'alumni avec possibilité d'appliquer des filtres basiques. Utilise la recherche full-text pour trouver des correspondances dans tous les champs. ",
        tags = { "Recherche Alumni" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Résultats de recherche récupérés avec succès", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = SearchResultsDTO.class))
            }),
            @ApiResponse(responseCode = "400", description = "Paramètres de recherche invalides")
        },
        security = {
            @SecurityRequirement(name = "bearerAuth")
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/api/v1/alumni/search",
        produces = { "application/json" }
    )
    @ResponseStatus(HttpStatus.OK)
    
    SearchResultsDTO searchAlumni(
        @Parameter(name = "q", description = "Terme de recherche général", in = ParameterIn.QUERY) @Valid @RequestParam(value = "q", required = false) String q,
        @Parameter(name = "filiere", description = "Filtrer par filière", in = ParameterIn.QUERY) @Valid @RequestParam(value = "filiere", required = false) String filiere,
        @Parameter(name = "niveau", description = "Filtrer par niveau d'études", in = ParameterIn.QUERY) @Valid @RequestParam(value = "niveau", required = false) String niveau,
        @Parameter(name = "entreprise", description = "Filtrer par entreprise actuelle", in = ParameterIn.QUERY) @Valid @RequestParam(value = "entreprise", required = false) String entreprise,
        @Parameter(name = "ville", description = "Filtrer par ville", in = ParameterIn.QUERY) @Valid @RequestParam(value = "ville", required = false) String ville
    );


    /**
     * DELETE /api/v1/roles/{id} : Supprimer logiquement un rôle
     * Effectue une suppression logique (soft delete) d&#39;un rôle en fonction de son ID
     *
     * @param id ID du rôle à supprimer logiquement (required)
     * @return Rôle supprimé logiquement avec succès (status code 204)
     *         or ID invalide (status code 400)
     *         or Rôle non trouvé (status code 404)
     */
    @Operation(
        operationId = "softDeleteRole",
        summary = "Supprimer logiquement un rôle",
        description = "Effectue une suppression logique (soft delete) d'un rôle en fonction de son ID",
        tags = { "Rôle" },
        responses = {
            @ApiResponse(responseCode = "204", description = "Rôle supprimé logiquement avec succès"),
            @ApiResponse(responseCode = "400", description = "ID invalide"),
            @ApiResponse(responseCode = "404", description = "Rôle non trouvé")
        },
        security = {
            @SecurityRequirement(name = "bearerAuth")
        }
    )
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/api/v1/roles/{id}"
    )
    @ResponseStatus(HttpStatus.NO_CONTENT)
    
    void softDeleteRole(
        @Parameter(name = "id", description = "ID du rôle à supprimer logiquement", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id
    );


    /**
     * PUT /api/v1/roles/{id} : Mettre à jour un rôle existant
     * Met à jour les informations d&#39;un rôle existant en fonction de son ID
     *
     * @param id ID du rôle à mettre à jour (required)
     * @param roleRequestDTO  (required)
     * @return Rôle mis à jour avec succès (status code 200)
     *         or Données de requête invalides (status code 400)
     *         or Rôle non trouvé (status code 404)
     */
    @Operation(
        operationId = "updateRole",
        summary = "Mettre à jour un rôle existant",
        description = "Met à jour les informations d'un rôle existant en fonction de son ID",
        tags = { "Rôle" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Rôle mis à jour avec succès", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = RoleResponseDTO.class))
            }),
            @ApiResponse(responseCode = "400", description = "Données de requête invalides"),
            @ApiResponse(responseCode = "404", description = "Rôle non trouvé")
        },
        security = {
            @SecurityRequirement(name = "bearerAuth")
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/api/v1/roles/{id}",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    @ResponseStatus(HttpStatus.OK)
    
    RoleResponseDTO updateRole(
        @Parameter(name = "id", description = "ID du rôle à mettre à jour", required = true, in = ParameterIn.PATH) @PathVariable("id") Long id,
        @Parameter(name = "RoleRequestDTO", description = "", required = true) @Valid @RequestBody RoleRequestDTO roleRequestDTO
    );


    /**
     * POST /api/v1/auth/validate-token : Valider un token JWT
     * Vérifie la validité et l&#39;intégrité d&#39;un token JWT. Utile pour les validations côté client ou pour les microservices. 
     *
     * @return Token valide (status code 200)
     *         or Token invalide ou expiré (status code 401)
     */
    @Operation(
        operationId = "validateToken",
        summary = "Valider un token JWT",
        description = "Vérifie la validité et l'intégrité d'un token JWT. Utile pour les validations côté client ou pour les microservices. ",
        tags = { "Authentification" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Token valide", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = TokenValidationResponse.class))
            }),
            @ApiResponse(responseCode = "401", description = "Token invalide ou expiré", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        },
        security = {
            @SecurityRequirement(name = "bearerAuth")
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/auth/validate-token",
        produces = { "application/json" }
    )
    @ResponseStatus(HttpStatus.OK)
    
    TokenValidationResponse validateToken(
        
    );


    /**
     * POST /api/v1/validation/verifier
     *
     * @param codeValidationCheckDTO  (required)
     * @return OK (status code 200)
     */
    @Operation(
        operationId = "verifierCode",
        tags = { "code-validation-controller" },
        responses = {
            @ApiResponse(responseCode = "200", description = "OK", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = String.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/api/v1/validation/verifier",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    @ResponseStatus(HttpStatus.OK)
    
    String verifierCode(
        @Parameter(name = "CodeValidationCheckDTO", description = "", required = true) @Valid @RequestBody CodeValidationCheckDTO codeValidationCheckDTO
    );

}
